module java/names/TypeNames

imports

  signatures/java/names/Names-sig

  java/names/Main
  java/names/PackageOrTypeNames
  java/types/Main
  java/types/ReferenceTypes


// 6.5.5 Meaning of Type Names

signature

  sorts
    TYPE_DECL  = (Id * scope)
    TYPE_PATH  = (path * (Id * scope))

  relations
    type : Id -> scope
    this : TYPE_DECL


rules

  typeDeclId : TYPE_DECL -> Id

  typeDeclId((id, _)) = id.


  typeDeclScope : TYPE_DECL -> scope

  typeDeclScope((_, s_ty)) = typeScope(toType(s_ty)).


  typeDeclType : TYPE_DECL -> TYPE

  typeDeclType((_, s_ty)) = toType(s_ty).


  typeDeclKind : TYPE_DECL -> KIND

  typeDeclKind((_, s_ty)) = toKind(s_ty).


rules

  typeNameOk : scope * TypeName -> TYPE_DECL

  typeNameOk(s, typeName) = resolveTypeName(s, typeNameOk1(typeName)).

      typeNameOk1 : TypeName -> QID

      typeNameOk1(TypeName(id)) = ID(id).

      typeNameOk1(TypeName(pkgOrTypeName, id)) = QID(pkgOrTypeNameOk1(pkgOrTypeName), id).


  resolveTypeName : scope * QID -> TYPE_DECL

  resolveTypeName(s, ID(id)) = typeDecl :-
    typeDecl == singleTypeDecl(id, resolveLexicalTypeNames(s, id)).

  resolveTypeName(s, QID(qid, id)) = typeDecl :-
  {s_pkgOrType}
    s_pkgOrType == pkgOrTypeDeclScope(resolvePkgOrTypeName(s, qid)),
    typeDecl == singleTypeDecl(id, resolveMemberTypeNames(s_pkgOrType, id)).


  resolveLexicalTypeNames : scope * Id -> list(TYPE_PATH)

  resolveLexicalTypeNames(s, id) = typePathList :-
    query type
      filter /* lex type re */
          LEX* (PKGC | IMP_ST | IMP_OD PKGC?)? EXT* IMPL*
        and { id' :- id' == id }
      min /* type ord */
          $ < LEX, $ < IMP_OD, $ < EXT,
          IMP_ST < PKGC, IMP_ST < IMP_OD,
          PKGC < IMP_OD
        and true
      in s |-> typePathList,
    true.


  resolveMemberTypeNames : scope * Id -> list(TYPE_PATH)

  resolveMemberTypeNames(s, id) = typePathList :-
    query type
      filter /* lex type re */
          PKGC? EXT* IMPL*
        and { id' :- id' == id }
      min /* type ord */
          $ < LEX, $ < IMP_OD, $ < EXT,
          IMP_ST < PKGC, IMP_ST < IMP_OD,
          PKGC < IMP_OD
        and true
      in s |-> typePathList,
    true.


  singleTypeDecl : Id * list(TYPE_PATH) -> TYPE_DECL

  singleTypeDecl(id, []) = _ :-
    false | error $[Type [id] not found] @id.

  singleTypeDecl(id, [(_, typeDecl@(id', _))]) = typeDecl :-
    @id.ref := id'.

  singleTypeDecl(id, typeDeclList) = _ :-
    false | error $[Type [id] is ambiguous] @id.


  declareType : scope * Id * scope * KIND

  declareType(s, id, s_ty, K) :-
    setType(s_ty, REF(s_ty)),
    setKind(s_ty, K),
    !type[id, s_ty] in s,
    !this[(id, s_ty)] in s_ty.


  aliasType : scope * TYPE_DECL

  aliasType(s, (id, s_ty)) :-
    !type[id, s_ty] in s.


  this : scope -> TYPE_DECL

  this(s) = typeDecl :-
    query this
      filter LEX* and true
      min $ < LEX and true
      in s |-> [(_, typeDecl)].


  super : scope -> TYPE_DECL

  super(s) = typeDecl' :-
  {s_this}
    s_this == typeDeclScope(this(s)),
    query this
      filter EXT|IMPL and true
      min EXT < IMPL and true
      in s_this |-> [(_, typeDecl')].

