module java/names/TypeNames

imports

  signatures/java/names/Names-sig

  java/names/Main
  java/names/PackageOrTypeNames
  java/types/Main


// 6.5.5 Meaning of Type Names

signature

  sorts
    TYPE_DECL  = (Id * TYPE)
    TYPE_PATH  = (path * (Id * scope))

  relations
    type : Id -> scope


rules

  typeNameOk : scope * TypeName -> TYPE_DECL
  
  typeNameOk(s, TypeName(id)) = typeDecl :-
    typeDecl == singleTypeDecl(id, resolveLexicalTypeNames(s, id)),
    true.
    
  typeNameOk(s, TypeName(pkgOrTypeName, id)) = typeDecl :-
  {s_pkgOrType}
    s_pkgOrType == pkgOrTypeDeclScope(pkgOrTypeNameOk(s, pkgOrTypeName)),
    typeDecl == singleTypeDecl(id, resolveMemberTypeNames(s_pkgOrType, id)),
    true.


  typeDeclScope : TYPE_DECL -> scope
  
  typeDeclScope((_, _)) = s_ty.


  resolveLexicalTypeNames : scope * Id -> list(TYPE_PATH)
  
  resolveLexicalTypeNames(s, id) = typePathList :-
    query type
      filter /* lex type re */
          LEX* (PKGC | IMP_ST | IMP_OD PKGC?)? EXT* IMPL*
        and { id' :- id' == id }
      min /* type ord */
          $ < LEX, $ < IMP_OD, $ < EXT,
          IMP_ST < PKGC, IMP_ST < IMP_OD,
          PKGC < IMP_OD
        and true
      in s |-> typePathList,
    true.


  resolveMemberTypeNames : scope * Id -> list(TYPE_PATH)
  
  resolveMemberTypeNames(s, id) = typePathList :-
    query type
      filter /* lex type re */
          PKGC? EXT* IMPL*
        and { id' :- id' == id }
      min /* type ord */
          $ < LEX, $ < IMP_OD, $ < EXT,
          IMP_ST < PKGC, IMP_ST < IMP_OD,
          PKGC < IMP_OD
        and true
      in s |-> typePathList,
    true.


  singleTypeDecl : Id * list(TYPE_PATH) -> TYPE_DECL
  
  singleTypeDecl(id, []) = _ :-
    false | error $[Type [id] not found] @id.

  singleTypeDecl(id, [(_, typeDecl)]) = (id, T) :-
    (id, matchType(T)) == typeDecl.

  singleTypeDecl(id, _) = _ :-
    false | error $[Type [id] is ambiguous] @id.

