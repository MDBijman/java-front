module statics

signature

  ////////////////////////////////////////////////////////
  // 3.8. Identifiers
  ////////////////////////////////////////////////////////

  sorts Id constructors
    Id : string -> Id

  ////////////////////////////////////////////////////////
  // 4.3. Reference Types and Values
  ////////////////////////////////////////////////////////

  sorts ReferenceType = ClassType
                   // = ArrayType

  sorts ClassType constructors
    ClassType : list(Annotation) * Id * MaybeTypeArguments -> ClassType
    ClassOrInterfaceTypeMember : ClassType * list(Annotation) * Id * MaybeTypeArguments -> ClassType

  ////////////////////////////////////////////////////////
  // 4.5. Parameterized Types
  ////////////////////////////////////////////////////////

  sorts MaybeTypeArguments = list(TypeArguments)
  sorts TypeArguments constructors
    TypeArguments : list(TypeArgument) -> TypeArguments

  sorts TypeArgument = ReferenceType
                  // = Wildcard

  ////////////////////////////////////////////////////////
  // 6.5. Determining the Meaning of a Name
  ////////////////////////////////////////////////////////

  sorts PackageName constructors
    PackageName : Id -> PackageName
    PackageName : PackageName * Id -> PackageName

  sorts TypeName constructors
    TypeName : Id -> TypeName
    TypeName : PackageOrTypeName * Id -> TypeName

  sorts PackageOrTypeName constructors
    PackageOrTypeName : Id -> PackageOrTypeName
    PackageOrTypeName : PackageOrTypeName * Id -> PackageOrTypeName

  ////////////////////////////////////////////////////////
  // 7.3. Compilation Units
  ////////////////////////////////////////////////////////

  sorts CompilationUnit constructors
    CompilationUnit : MaybePackageDeclaration * list(ImportDeclaration) * list(TypeDeclaration) -> CompilationUnit

  sorts TypeDeclaration constructors

  ////////////////////////////////////////////////////////
  // 7.4. Package Declarations
  ////////////////////////////////////////////////////////

  sorts MaybePackageDeclaration = list(PackageDeclaration)
  sorts PackageDeclaration constructors
    PackageDeclaration : list(Annotation) * list(Id) -> PackageDeclaration

  ////////////////////////////////////////////////////////
  // 7.5. Import Declarations
  ////////////////////////////////////////////////////////

  sorts ImportDeclaration constructors
    SingleTypeImport     : TypeName -> ImportDeclaration
    TypeImportOnDemand   : PackageOrTypeName -> ImportDeclaration

  ////////////////////////////////////////////////////////
  // 8.1. Class Declarations
  ////////////////////////////////////////////////////////

  constructors
    // ClassDeclaration => TypeDeclaration
    ClassDeclaration : list(ClassModifier) * Id * MaybeTypeParameters * MaybeSuperClass * MaybeSuperInterfaces * list(ClassBodyDeclaration) -> TypeDeclaration

  sorts ClassModifier

  sorts MaybeTypeParameters = list(TypeParameters)
  sorts TypeParameters

  sorts MaybeSuperClass = list(SuperClass)
  sorts SuperClass constructors
    SuperClass : ClassType -> SuperClass

  sorts MaybeSuperInterfaces = list(SuperInterfaces)
  sorts SuperInterfaces constructors
    SuperInterface : list(ClassType) -> SuperInterfaces

  sorts ClassBodyDeclaration

  ////////////////////////////////////////////////////////
  // 8.9. Enum Types
  ////////////////////////////////////////////////////////

  constructors
    // EnumDeclaration => TypeDeclaration
    EnumDeclComma : list(ClassModifier) * Id * MaybeSuperInterfaces * list(EnumConstant) * MaybeEnumBodyDeclarations -> TypeDeclaration
    EnumDecl : list(ClassModifier) * Id * MaybeSuperInterfaces * list(EnumConstant) * MaybeEnumBodyDeclarations -> TypeDeclaration

  sorts EnumConstant

  sorts MaybeEnumBodyDeclarations = list(EnumBodyDeclarations)
  sorts EnumBodyDeclarations

  ////////////////////////////////////////////////////////
  // 9.1. Interface Declarations
  ////////////////////////////////////////////////////////

  constructors
    // InterfaceDeclaration => TypeDeclaration
    NormalInterface : list(InterfaceModifier) * Id * MaybeTypeParameters * MaybeExtendsInterfaces * list(InterfaceMemberDeclaration) -> TypeDeclaration

  sorts InterfaceModifier
  
  sorts MaybeExtendsInterfaces = list(ExtendsInterfaces)
  sorts ExtendsInterfaces constructors
    ExtendsInterfaces : list(ClassType) -> ExtendsInterfaces
  
  sorts InterfaceMemberDeclaration

  ////////////////////////////////////////////////////////
  // 9.6. Annotation Types
  ////////////////////////////////////////////////////////

  constructors
    // AnnotationTypeDeclaration => TypeDeclaration
    AnnoDec : list(InterfaceModifier) * Id * list(AnnotationTypeMemberDeclaration) -> TypeDeclaration

  sorts AnnotationTypeMemberDeclaration

  ////////////////////////////////////////////////////////
  // 9.7. Annotations
  ////////////////////////////////////////////////////////

  sorts Annotation


signature

  sorts PKG = (path * (occurrence * scope))

  sorts TYPE constructors
    ANNO  : scope -> TYPE
    CLASS : scope -> TYPE
    INTF  : scope -> TYPE
    ENUM  : scope -> TYPE

  name-resolution
    labels LEX  // lexical parent
           PKG  // package composition
           IMP  // import
           EXT  // extends
           IMPL // implements
    resolve Pkg  filter LEX*
                 min    $ < LEX
    resolve Type filter LEX*(e|PKG|IMP)
                 min    $ < LEX, $ < PKG, $ < IMP, IMP < PKG, PKG < LEX

  namespaces
    Type : Id
    Pkg  : list(Id)

  relations
    types    : occurrence -> TYPE
    packages : occurrence -> scope


rules

  projectOk : scope

  projectOk(s).


rules

  fileOk : scope * CompilationUnit

  fileOk(s, CompilationUnit(maybePackageDeclaration, importDeclarations, typeDeclarations)) :-
  {s_cu}
    new s_cu, s_cu -LEX-> s,
    maybePackageDeclarationOk(s, maybePackageDeclaration, s_cu),
    importDeclarationsOk(s, importDeclarations, s_cu),
    typeDeclarationsOk(s_cu, typeDeclarations).


rules

  maybePackageDeclarationOk maps packageDeclarationOk(*, list(*), *)
  
  packageDeclarationOk : scope * PackageDeclaration * scope
  
  packageDeclarationOk(s, p@PackageDeclaration(annotations, ids), s_pkg) :-
  {pkgs}
    !packages[Pkg{ids@p}, s_pkg] in s,
    packages of Pkg{ids@-} in s |-> pkgs,
    composePackages(s_pkg, pkgs).


  composePackages maps composePackage(*, list(*))

  composePackage : scope * PKG

  composePackage(s, (_, (_, s'))) :-
    s -PKG-> s'.


rules

  importDeclarationsOk maps importDeclarationOk(*, list(*), *)

  importDeclarationOk : scope * ImportDeclaration * scope

  importDeclarationOk(s, SingleTypeImport(typeName), s_cu) :-
  {s_imp d type}
    new s_imp, s_cu -IMP-> s_imp,
    resolveTypeName(s, typeName) == (d, type),
    !types[d, type] in s_imp.

  importDeclarationOk(s, TypeImportOnDemand(packageOrTypeName), s_cu) :-
  {pkgs}
    resolvePackageOrTypeName(s, packageOrTypeName) == pkgs,
    importPackages(s_cu, pkgs).


  resolveTypeName : scope * TypeName -> (occurrence * TYPE)
  
  resolveTypeName(s, TypeName(id)) = type :-
  {id'} @id.ref := id',
    types of Type{id@-} in s |-> [(_, type@(Type{id'@_}, _))]. // FIXME Is `s` correct here, or should that be the package scope?

  resolveTypeName(s, TypeName(packageOrTypeName, id)) = type :-
  {s_imp pkgs}
    new s_imp,
    resolvePackageOrTypeName(s, packageOrTypeName) == pkgs,
    importPackages(s_imp, pkgs),
    resolveTypeName(s_imp, TypeName(id)) == type.

  
  resolvePackageOrTypeName : scope * PackageOrTypeName -> list(PKG)

  resolvePackageOrTypeName(s, packageOrTypeName) = pkgs :-
  {x i}
    packageOrTypeName2Pkg(packageOrTypeName, []) == Pkg{x@i},
    packages of Pkg{x@i} in s |-> pkgs.


  packageOrTypeName2Pkg : PackageOrTypeName * list(Id) -> occurrence
  
  packageOrTypeName2Pkg(PackageOrTypeName(id), ids) = Pkg{[id|ids]@-}.

  packageOrTypeName2Pkg(PackageOrTypeName(packageOrTypeName, id), ids) =
    packageOrTypeName2Pkg(packageOrTypeName, [id|ids]).


  importPackages maps importPackage(*, list(*))

  importPackage : scope * PKG

  importPackage(s, (_, (_, s'))) :-
    s -IMP-> s'.


rules

  typeDeclarationsOk maps typeDeclarationOk(*, list(*))

  typeDeclarationOk : scope * TypeDeclaration

  typeDeclarationOk(s, ClassDeclaration(classModifiers, id, maybeTypeParameters, maybeSuperClass, maybeSuperInterfaces, classBodyDeclarations)) :-
  {s_cls}
    new s_cls, s_cls -LEX-> s,
    !types[Type{id@id}, CLASS(s_cls)] in s,
    maybeSuperClassOk(s, maybeSuperClass, s_cls),
    maybeSuperInterfacesOk(s, maybeSuperInterfaces, s_cls).

  typeDeclarationOk(s, EnumDeclComma(classModifiers, id, maybeSuperInterfaces, enumConstants, maybeEnumBodyDeclarations)) :-
  {s_enum}
    new s_enum, s_enum -LEX-> s,
    !types[Type{id@id}, ENUM(s_enum)] in s,
    maybeSuperInterfacesOk(s, maybeSuperInterfaces, s_enum).

  typeDeclarationOk(s, EnumDecl(classModifiers, id, maybeSuperInterfaces, enumConstants, maybeEnumBodyDeclarations)) :-
  {s_enum}
    new s_enum, s_enum -LEX-> s,
    !types[Type{id@id}, ENUM(s_enum)] in s,
    maybeSuperInterfacesOk(s, maybeSuperInterfaces, s_enum).

  typeDeclarationOk(s, NormalInterface(interfaceModifiers, id, maybeTypeParameters, maybeExtendsInterfaces, interfaceMemberDeclarations)) :-
  {s_intf}
    new s_intf, s_intf -LEX-> s,
    !types[Type{id@id}, INTF(s_intf)] in s,
    maybeExtendsInterfacesOk(s, maybeExtendsInterfaces).

  typeDeclarationOk(s, AnnoDec(interfaceModifiers, id, annotationTypeMemberDeclarations)) :-
  {s_anno}
    new s_anno, s_anno -LEX-> s,
    !types[Type{id@id}, ANNO(s_anno)] in s.

rules

  maybeSuperClassOk maps superClassOk(*, list(*), *)

  superClassOk : scope * SuperClass * scope
  
  superClassOk(s, SuperClass(classType), s_this) :-
  {s_super}
    classTypeOk(s, classType) == CLASS(s_super),
    s_this -EXT-> s_super.


rules

  maybeSuperInterfacesOk maps superInterfacesOk(*, list(*), *)

  superInterfacesOk : scope * SuperInterfaces * scope
  
  superInterfacesOk(s, SuperInterface(classTypes), s_this) :-
  {types}
    classTypesOk(s, classTypes) == types,
    implementInterfaces(types, s).


  implementInterfaces maps implementInterface(list(*), *)

  implementInterface : TYPE * scope

  implementInterface(INTF(s_intf), s_this) :-
    s_this -IMPL-> s_intf.


rules

  maybeExtendsInterfacesOk maps extendsInterfacesOk(*, list(*))
  
  extendsInterfacesOk : scope * ExtendsInterfaces

  extendsInterfacesOk(s, ExtendsInterfaces(classTypes)) :-
    classTypesOk(s, classTypes) == _.


rules

  classTypesOk maps classTypeOk(*, list(*)) = list(*)

  classTypeOk : scope * ClassType -> TYPE
  
  classTypeOk(s, ClassType(annotations, id, maybeTypeArguments)) = ty :-
  {id'} @id.ref := id',
    types of Type{id@-} in s |-> [(_, (Type{id'@_}, ty))].

  classTypeOk(s, ClassOrInterfaceTypeMember(classType, annotations, id, maybeTypeArguments)) = ty :-
  {x i pkgs s_imp}
    classType2Pkg(classType, []) == Pkg{x@i},
    packages of Pkg{x@i} in s |-> pkgs,
    new s_imp,
    importPackages(s_imp, pkgs),
    classTypeOk(s_imp, ClassType(annotations, id, maybeTypeArguments)) == ty.


  classType2Pkg : ClassType * list(Id) -> occurrence
  
  classType2Pkg(ClassType(_, id, _), ids) = Pkg{[id|ids]@-}.

  classType2Pkg(ClassOrInterfaceTypeMember(classType, _, id, _), ids) =
    classType2Pkg(classType, [id|ids]).
