module statics

imports

  statics/arrays
  statics/classes
  statics/expressions
  statics/interfaces
  statics/literals
  statics/names
  statics/packages
  statics/statements
  statics/types

/*
rules

  projectOk : scope

  projectOk(s) :- {s_object s_array tLength}
    //Extend object in the program scope
    CLASS(s_object) == classTypeOkNoId(s, ClassOrInterfaceTypeMember(ClassOrInterfaceTypeMember(ClassType([], Id("java"), []), [], Id("lang"), []), [], Id("Object"), [])),
    s -EXT-> s_object,
    
    //Array with length field
    new s_array, s_array -LEX-> s_object,
    !scopes[Builtin{"array"@-}, s_array] in s,
    tLength == Id("length"),
    !types[Var{tLength@-}, PRIMITIVE()] in s_array.


rules

  fileOk : scope * CompilationUnit

  fileOk(s, CompilationUnit(maybePackageDeclaration, importDeclarations, typeDeclarations)) :-
  {s_cu}
    new s_cu, s_cu -LEX-> s,
    maybePackageDeclarationOk(s, maybePackageDeclaration, s_cu),
    importDeclarationsOk(s, importDeclarations, s_cu),
    typeDeclarationsOk(s_cu, typeDeclarations).


imports

  signatures/java/Main-sig

signature

  sorts PKG = (path * (occurrence * scope))

  sorts TYPE constructors
    ANNO  : scope -> TYPE
    CLASS : scope -> TYPE
    INTF  : scope -> TYPE
    ENUM  : scope -> TYPE
    PRIMITIVE : TYPE
    ARRAY : TYPE -> TYPE
    FUNCTION : list(TYPE) * TYPE -> TYPE
    VOID : TYPE

  name-resolution
    labels LEX  // lexical parent
           PKG  // package composition
           IMP  // import
           EXT  // extends
           IMPL // implements
    resolve Pkg  filter LEX*
                 min    $ < LEX
    resolve Type filter LEX*(e|PKG|IMP)
                 min    $ < LEX, $ < PKG, $ < IMP, IMP < PKG, PKG < LEX
    resolve Method filter LEX*EXT*IMPL*
                   min    $ < LEX, $ < EXT, $ < IMPL, EXT < LEX, IMPL < LEX, EXT < IMPL
    resolve Var filter LEX*EXT*
                min $ < LEX, $ < EXT, EXT < LEX
    resolve Builtin filter LEX*
                    min $ < LEX

  namespaces
    Type : Id
    Pkg  : list(Id)
    Method : Id
    Var : Id
    Builtin : string

  relations
    types    : occurrence -> TYPE
    packages : occurrence -> scope
    scopes   : occurrence -> scope
    supers   : occurrence -> list(occurrence)


rules

  maybePackageDeclarationOk maps packageDeclarationOk(*, list(*), *)
  
  packageDeclarationOk : scope * PackageDeclaration * scope
  
  packageDeclarationOk(s, p@PackageDeclaration(annotations, ids), s_pkg) :-
  {pkgs}
    !packages[Pkg{ids@p}, s_pkg] in s,
    packages of Pkg{ids@-} in s |-> pkgs,
    composePackages(s_pkg, pkgs).


  composePackages maps composePackage(*, list(*))

  composePackage : scope * PKG

  composePackage(s, (_, (_, s'))) :-
    s -PKG-> s'.


rules

  importDeclarationsOk maps importDeclarationOk(*, list(*), *)

  importDeclarationOk : scope * ImportDeclaration * scope

  importDeclarationOk(s, SingleTypeImport(typeName), s_cu) :-
  {s_imp l}
    new s_imp, s_cu -IMP-> s_imp,
    resolveTypeNameAsList(s, typeName) == l,
    addImportIfFound(s, s_imp, typeName, l).

  importDeclarationOk(s, TypeImportOnDemand(packageOrTypeName), s_cu) :-
  {pkgs}
    resolvePackageOrTypeName(s, packageOrTypeName) == pkgs,
    importPackages(s_cu, pkgs).

  //Add the first import that we find (if there are multiple classes with the same full name, we pick the first one).
  //Otherwise, invent the imported type and associate it a class.
  addImportIfFound : scope * scope * TypeName * list((path * (occurrence * TYPE)))
  addImportIfFound(s, s_imp, _, [(_, (occ, type))]) :-
    !types[occ, type] in s_imp.
  addImportIfFound(s, s_imp, _, [(_, (occ, type)) | _]) :-
    !types[occ, type] in s_imp,
    false.
  addImportIfFound(s, s_imp, TypeName(id), []) :- {s_notfound}
    new s_notfound, s_notfound -LEX-> s,
    !types[Type{id@-}, CLASS(s_notfound)] in s_imp,
    false.
  addImportIfFound(s, s_imp, TypeName(_, id), []) :- {s_notfound}
    new s_notfound, s_notfound -LEX-> s,
    !types[Type{id@-}, CLASS(s_notfound)] in s_imp,
    false.
  
  
  resolveTypeNameAsList : scope * TypeName -> list((path * (occurrence * TYPE)))
  
  resolveTypeNameAsList(s, TypeName(id)) = l :-
    types of Type{id@-} in s |-> l.
  
  resolveTypeNameAsList(s, TypeName(packageOrTypeName, id)) = l :-
  {s_imp pkgs}
    new s_imp,
    resolvePackageOrTypeName(s, packageOrTypeName) == pkgs,
    importPackages(s_imp, pkgs),
    resolveTypeNameAsList(s_imp, TypeName(id)) == l.

  resolveTypeName : scope * TypeName -> (occurrence * TYPE)
  
  resolveTypeName(s, TypeName(id)) = type :-
    types of Type{id@-} in s |-> [(_, type)]. // FIXME Is `s` correct here, or should that be the package scope?

  resolveTypeName(s, TypeName(packageOrTypeName, id)) = type :-
  {s_imp pkgs}
    new s_imp,
    resolvePackageOrTypeName(s, packageOrTypeName) == pkgs,
    importPackages(s_imp, pkgs),
    resolveTypeName(s_imp, TypeName(id)) == type.
  
  resolveTypeName2 : scope * TypeName -> (occurrence * TYPE)
  
  resolveTypeName2(s, TypeName(id)) = type :-
    types of Type{id@-} in s |-> [(_, type)]. // FIXME Is `s` correct here, or should that be the package scope?

  resolveTypeName2(s, TypeName(packageOrTypeName, id)) = type :-
  {s_imp pkgs}
    new s_imp,
    resolvePackageOrTypeName(s, packageOrTypeName) == pkgs,
    importPackages(s_imp, pkgs),
    resolveTypeName2(s_imp, TypeName(id)) == type.

  
  resolvePackageOrTypeName : scope * PackageOrTypeName -> list(PKG)

  resolvePackageOrTypeName(s, packageOrTypeName) = pkgs :-
  {x i}
    packageOrTypeName2Pkg(packageOrTypeName, []) == Pkg{x@i},
    packages of Pkg{x@i} in s |-> pkgs.


  packageOrTypeName2Pkg : PackageOrTypeName * list(Id) -> occurrence
  
  packageOrTypeName2Pkg(PackageOrTypeName(id), ids) = Pkg{[id|ids]@-}.

  packageOrTypeName2Pkg(PackageOrTypeName(packageOrTypeName, id), ids) =
    packageOrTypeName2Pkg(packageOrTypeName, [id|ids]).


  importPackages maps importPackage(*, list(*))

  importPackage : scope * PKG

  importPackage(s, (_, (_, s'))) :-
    s -IMP-> s'.


rules

  typeDeclarationsOk maps typeDeclarationOk(*, list(*))

  typeDeclarationOk : scope * TypeDeclaration

  typeDeclarationOk(s, ClassDeclaration2TypeDeclaration(cd)) :-
    classDeclarationOk(s, cd).

  typeDeclarationOk(s, InterfaceDeclaration2TypeDeclaration(id)) :-
    interfaceDeclarationOk(s, id).


rules

  classDeclarationsOk maps classDeclarationOk(*, list(*))

  classDeclarationOk : scope * ClassDeclaration

  classDeclarationOk(s, NormalClassDeclaration2ClassDeclaration(ncd)) :-
    normalClassDeclarationOk(s, ncd).

  classDeclarationOk(s, EnumDeclaration2ClassDeclaration(ed)) :-
    enumDeclarationOk(s, ed).


rules

  normalClassDeclarationsOk maps normalClassDeclarationOk(*, list(*))

  normalClassDeclarationOk : scope * NormalClassDeclaration

  normalClassDeclarationOk(s, ClassDeclaration(normalClassModifiers, id, maybeTypeParameters, maybeSuperClass, maybeSuperInterfaces, normalClassBodyDeclarations)) :-
//  modbound normalClassDeclarationOk(s, ClassDeclaration(normalClassModifiers, id@Id(name), maybeTypeParameters, maybeSuperClass, maybeSuperInterfaces, normalClassBodyDeclarations))
//  | $[[name]] :-
  {s_cls tThis}
    new s_cls, s_cls -LEX-> s,
    !types[Type{id@id}, CLASS(s_cls)] in s,
    tThis == Id("this"), !types[Var{tThis@-}, CLASS(s_cls)] in s_cls,
    maybeSuperClassOk(s, maybeSuperClass, s_cls),
    maybeSuperInterfacesOk(s, maybeSuperInterfaces, s_cls),
    maybeClassBodyDeclarationsOk(s, normalClassBodyDeclarations, s_cls).
  
  flatten : list(list(occurrence)) -> list(occurrence)
  flatten([]) = [].
  flatten([[]]) = [].
  flatten([ l ]) = l.
  flatten([ [h | t1] | t2]) = [h | join(t1, flatten(t))].
  
  join: list(occurrence) * list(occurrence) -> list(occurrence)
  join([], l) = l.
  join([h | t], l) = [h | join(t, l)].

rules

  enumDeclarationsOk maps enumDeclarationOk(*, list(*))

  enumDeclarationOk : scope * EnumDeclaration

  enumDeclarationOk(s, EnumDeclComma(classModifiers, id, maybeSuperInterfaces, enumConstants, maybeEnumBodyDeclarations)) :-
//  modbound enumDeclarationOk(s, EnumDeclComma(classModifiers, id@Id(name), maybeSuperInterfaces, enumConstants, maybeEnumBodyDeclarations))
//  | $[[name]] :-
  {s_enum tThis}
    new s_enum, s_enum -LEX-> s,
    !types[Type{id@id}, ENUM(s_enum)] in s,
    tThis == Id("this"), !types[Var{tThis@-}, ENUM(s_enum)] in s_enum,
    maybeSuperInterfacesOk(s, maybeSuperInterfaces, s_enum).

  enumDeclarationOk(s, EnumDecl(classModifiers, id, maybeSuperInterfaces, enumConstants, maybeEnumBodyDeclarations)) :-
//  modbound enumDeclarationOk(s, EnumDecl(classModifiers, id@Id(name), maybeSuperInterfaces, enumConstants, maybeEnumBodyDeclarations))
//  | $[[name]] :-
  {s_enum tThis}
    new s_enum, s_enum -LEX-> s,
    !types[Type{id@id}, ENUM(s_enum)] in s,
    tThis == Id("this"), !types[Var{tThis@-}, ENUM(s_enum)] in s_enum,
    maybeSuperInterfacesOk(s, maybeSuperInterfaces, s_enum).

rules

  interfaceDeclarationsOk maps interfaceDeclarationOk(*, list(*))

  interfaceDeclarationOk : scope * InterfaceDeclaration

  interfaceDeclarationOk(s, NormalInterface(interfaceModifiers, id, maybeTypeParameters, maybeExtendsInterfaces, interfaceMemberDeclarations)) :-
//  modbound interfaceDeclarationOk(s, NormalInterface(interfaceModifiers, id@Id(name), maybeTypeParameters, maybeExtendsInterfaces, interfaceMemberDeclarations))
//  | $[[name]] :-
  {s_intf tThis}
    new s_intf, s_intf -LEX-> s,
    !types[Type{id@id}, INTF(s_intf)] in s,
    tThis == Id("this"), !types[Var{tThis@-}, INTF(s_intf)] in s_intf,
    maybeExtendsInterfacesOk(s, maybeExtendsInterfaces),
    maybeInterfaceMemberDeclarationsOk(s, interfaceMemberDeclarations, s_intf).

  interfaceDeclarationOk(s, AnnotationTypeDeclaration2InterfaceDeclaration(atd)) :-
    annotationTypeDeclarationOk(s, atd).

rules

  annotationTypeDeclarationsOk maps annotationTypeDeclarationOk(*, list(*))

  annotationTypeDeclarationOk : scope * AnnotationTypeDeclaration

  annotationTypeDeclarationOk(s, AnnoDec(interfaceModifiers, id, annotationTypeMemberDeclarations)) :-
  {s_anno}
    new s_anno, s_anno -LEX-> s,
    !types[Type{id@id}, ANNO(s_anno)] in s.
  
  
rules

//This makes each class extend object
//  maybeSuperClassOk : scope * list(SuperClass) * scope -> list(occurrence)
//  maybeSuperClassOk(s, [], s_cls) = [occ] :- {s_obj}
//    (occ, CLASS(s_obj)) == classTypeOk2(s, ClassOrInterfaceTypeMember(ClassOrInterfaceTypeMember(ClassType([], Id("java"), []), [], Id("lang"), []), [], Id("Object"), [])),
//    s_cls -EXT-> s_obj.
//  maybeSuperClassOk(s, [super], s_cls) = [superClassOk(s, super, s_cls)].

  maybeSuperClassOk maps superClassOk(*, list(*), *)
  superClassOk : scope * SuperClass * scope
  superClassOk(s, SuperClass(classType), s_this) :-
  {s_super}
    classTypeOk(s_this, classType) == CLASS(s_super), //was lookup in s
    s_this -EXT-> s_super.


rules

  maybeSuperInterfacesOk maps superInterfacesOk(*, list(*), *)
  superInterfacesOk : scope * SuperInterfaces * scope
  superInterfacesOk(s, SuperInterface(classTypes), s_this) :-
  {types}
    classTypesOk(s_this, classTypes) == types, //was lookup in s
    implementInterfaces(types, s).

  implementInterfaces maps implementInterface(list(*), *)
  implementInterface : TYPE * scope
  implementInterface(INTF(s_intf), s_this) :-
    s_this -IMPL-> s_intf.


rules

  maybeExtendsInterfacesOk maps extendsInterfacesOk(*, list(*))
  extendsInterfacesOk : scope * ExtendsInterfaces
  extendsInterfacesOk(s, ExtendsInterfaces(classTypes)) :-
    classTypesOk(s, classTypes) == _.


rules

  classTypesOk maps classTypeOk(*, list(*)) = list(*)
  classTypeOk : scope * ClassType -> TYPE
  classTypeOk(s, ClassType(annotations, id, maybeTypeArguments)) = ty :-
    types of Type{id@-} in s |-> [(_, (_, ty))].

  classTypeOk(s, ClassOrInterfaceTypeMember(classType, annotations, id, maybeTypeArguments)) = ty :-
  {x i pkgs s_imp}
    classType2Pkg(classType, []) == Pkg{x@i},
    packages of Pkg{x@i} in s |-> pkgs,
    new s_imp,
    importPackages(s_imp, pkgs),
    classTypeOk(s_imp, ClassType(annotations, id, maybeTypeArguments)) == ty.
  
  //Does not add a termId
  classTypeOkNoId : scope * ClassType -> TYPE
  classTypeOkNoId(s, ClassType(annotations, id, maybeTypeArguments)) = T :-
    types of Type{id@-} in s |-> [(_, (_, T))].

  classTypeOkNoId(s, ClassOrInterfaceTypeMember(classType, annotations, id, maybeTypeArguments)) = T :-
  {x i pkgs s_imp}
    classType2Pkg(classType, []) == Pkg{x@i},
    packages of Pkg{x@i} in s |-> pkgs,
    new s_imp,
    importPackages(s_imp, pkgs),
    classTypeOkNoId(s_imp, ClassType(annotations, id, maybeTypeArguments)) == T.


  classType2Pkg : ClassType * list(Id) -> occurrence
  classType2Pkg(ClassType(_, id, _), ids) = Pkg{[id|ids]@-}.

  classType2Pkg(ClassOrInterfaceTypeMember(classType, _, id, _), ids) =
    classType2Pkg(classType, [id|ids]).

//-------------------------------------------------------------------------------------------------
//Bodies
//-------------------------------------------------------------------------------------------------
rules
  maybeClassBodyDeclarationsOk maps maybeClassBodyDeclarationOk(*, list(*), *)
  maybeClassBodyDeclarationOk: scope * ClassBodyDeclaration * scope
  
  maybeClassBodyDeclarationOk(s, ClassMemberDeclaration2ClassBodyDeclaration(cmd), s_cls) :-
    classMemberDeclarationOk(s, cmd, s_cls).
  
  classMemberDeclarationOk : scope * ClassMemberDeclaration * scope
  classMemberDeclarationOk(s, FieldDeclaration2ClassMemberDeclaration(field), s_cls) :-
    fieldDeclOk(s, field, s_cls).
  classMemberDeclarationOk(s, MethodDeclaration2ClassMemberDeclaration(MethodDecl(mods, header, body)), s_cls) :- {s_mtd}
    new s_mtd, s_mtd -LEX-> s_cls,
    methodHeaderOk(s, header, s_cls, s_mtd),
    methodBodyOk(s, body, s_mtd).
  
  //Inner class
  maybeClassBodyDeclarationOk(s, ClassMemberDeclaration2ClassBodyDeclaration(ClassDeclaration2ClassMemberDeclaration(cd)), s_cls) :-
    classDeclarationOk(s_cls, cd).
    
  //Inner interface
  maybeClassBodyDeclarationOk(s, ClassMemberDeclaration2ClassBodyDeclaration(InterfaceDeclaration2ClassMemberDeclaration(id)), s_cls) :-
    interfaceDeclarationOk(s_cls, id).
    
  //Initializer / Constructor
  maybeClassBodyDeclarationOk(_, _, _).
  
  //Interfaces
  maybeInterfaceMemberDeclarationsOk maps interfaceMemberDeclarationOk(*, list(*), *)
  interfaceMemberDeclarationOk : scope * InterfaceMemberDeclaration * scope
  interfaceMemberDeclarationOk(s, InterfaceMethodDeclaration2InterfaceMemberDeclaration(AbstractMethodDec(mods, header, body)), s_intf) :-
  {s_mtd}
    new s_mtd, s_mtd -LEX-> s_intf,
    methodHeaderOk(s, header, s_intf, s_mtd).
//  modbound interfaceMemberDeclarationOk(s, IMD2IMD(AbstractMethodDec(mods, uid, header, Block(stmts@[_ | _]))), s_intf) | $[[uid]] :-
  interfaceMemberDeclarationOk(s, InterfaceMethodDeclaration2InterfaceMemberDeclaration(AbstractMethodDec(mods, header, body)), s_intf) :-
  {s_mtd}
    new s_mtd, s_mtd -LEX-> s_intf,
    methodHeaderOk(s, header, s_intf, s_mtd),
    methodBodyOk(s, body, s_mtd).
  
  interfaceMemberDeclarationOk(s, ClassDeclaration2InterfaceMemberDeclaration(cd), s_intf) :-
    classDeclarationOk(s_intf, cd).
  
  interfaceMemberDeclarationOk(s, InterfaceDeclaration2InterfaceMemberDeclaration(id), s_intf) :-
    interfaceDeclarationOk(s_intf, id).
  
  interfaceMemberDeclarationOk(s, ConstDeclaration2InterfaceMemberDeclaration(fields), s_intf) :-
    maybeFieldDeclsOk(s, fields, s_intf).
  
  //Semicolon
  interfaceMemberDeclarationOk(_, _, _).
    

//-------------------------------------------------------------------------------------------------
//Fields
//-------------------------------------------------------------------------------------------------
rules
  maybeFieldDeclsOk maps maybeFieldDeclOk(*, list(*), *)

  fieldDeclOk : scope * FieldDeclaration * scope
  fieldDeclOk(s, FieldDecl(mods, ty, name), s_cls) :-
    !types[Var{name@name}, typeOk(s_cls, ty)] in s_cls.
  fieldDeclOk(s, FieldDeclArray(mods, ty, name, count), s_cls) :-
    !types[Var{name@name}, ARRAY(typeOk(s_cls, ty))] in s_cls.

//-------------------------------------------------------------------------------------------------
//Methods
//-------------------------------------------------------------------------------------------------
rules
  methodHeaderOk : scope * MethodHeader * scope * scope
  methodHeaderOk(s, MethodHeader(result, name, params, _, throws), s_cls, s_mtd) :- {rty ptys}
    !types[Method{name@name}, FUNCTION(ptys, rty)] in s_cls,
    rty == resultOk(s_cls, result),
    ptys == paramTypesOk(s_cls, params, s_mtd).
  methodHeaderOk(s, MethodHeaderTypeParameters(typs, annots, result, name, params, throws), s_cls, s_mtd) :- {rty ptys}
    !types[Method{name@name}, FUNCTION(ptys, rty)] in s_cls,
    rty == resultOk(s_cls, result),
    ptys == paramTypesOk(s_cls, params, s_mtd).
  
  paramTypesOk maps paramTypeOk(*, list(*), *) = list(*)
  paramTypeOk : scope * FormalParam * scope -> TYPE
  paramTypeOk(s, FormalParam(mods, ty, VariableDecl(id)), s_mtd) = T :-
    T == typeOk(s, ty),
    !types[Var{id@id}, T] in s_mtd.
  paramTypeOk(s, FormalParam(mods, ty, VariableDeclArray(id, dims)), s_mtd) = T :-
    T == typeOk(s, ty),
    !types[Var{id@id}, ARRAY(T)] in s_mtd.
  
  paramTypeOk(s, ReceiverParam(annots, ty), s_mtd) = typeOk(s, ty).
  paramTypeOk(s, ReceiverParamQual(annots, ty, id), s_mtd) = typeOk(s, ty).
    
  resultOk : scope * Result -> TYPE
  resultOk(s, UnannType2Result(ty)) = typeOf(s, ty).
  resultOk(s, Void()) = VOID().
    
  methodBodyOk : scope * MethodBody * scope
  methodBodyOk(s, NoMethodBody(), s_mthd).
  methodBodyOk(s, Block2MethodBody(Block(stmts)), s_mthd) :- statementsOk(s, stmts, s_mthd).
    
//-------------------------------------------------------------------------------------------------
//Statements
//-------------------------------------------------------------------------------------------------
rules
  statementsOk maps statementOk(*, list(*), *)
  statementOk: scope * Statement * scope
  statementOk(s, Statement2Block(Block(stmts)), s_method) :- {s_block}
    new s_block,
    s_block -LEX-> s_method,
    statementsOk(s, stmts, s_block).
  
  statementOk(s, ExpressionStatement(exp), s_mtd) :- {T}
    expressionOk(s, exp, s_mtd) == T.
  
  statementOk(s, ExpressionsStatement(exps), s_mtd) :- {Ts}
    expressionsOk(s, exps, s_mtd) == Ts.
  
  statementOk(s, VarDeclStatement(ty, name), s_mtd) :-
    !types[Var{name@name}, typeOk(s_mtd, ty)] in s_mtd.
  
  statementOk(s, ArrayVarDeclStatement(ty, name, dim), s_mtd) :-
    !types[Var{name@name}, ARRAY(typeOk(s_mtd, ty))] in s_mtd.

//-------------------------------------------------------------------------------------------------
//Blocks
//-------------------------------------------------------------------------------------------------
rules

  blockOk : scope * Block * scope
  blockOk(s, Block(bstmts), s_def) :- blockStatementsOk(s, bstmts, s_def).

  blockStatementsOk maps blockStatementOk(*, list(*), *)

  blockStatementOk : scope * BlockStatement * scope
  blockStatementOk(s, Statement2BlockStatement(stmt), s_def) :- statementOk(s, stmt, s_def).

//-------------------------------------------------------------------------------------------------
//Expressions
//-------------------------------------------------------------------------------------------------
rules
  expressionsOk maps expressionOk(*, list(*), *) = list(*)
  expressionOk : scope * Expression * scope -> TYPE
  
  expressionOk(s, ExpressionName2Expression(ExpressionName(id)), s_mtd) = T :-
    types of Var{id@-} in s_mtd |-> [(_, (_, T))].
  expressionOk(s, ExpressionName2Expression(ExpressionName(ambName, id)), s_mtd) = T :-
  {tyAmb sTyAmb} 
    handleAmbiguous(s_mtd, ambName) == [(_, (_, tyAmb))],
    scopeOf(s, tyAmb) == sTyAmb,
    types of Var{id@-} in sTyAmb |-> [(_, (_, T))].
  
  //Fields
  expressionOk(s, FieldAccess2Expression(Field(exp, id)), s_mtd) = T :-
    {Texp s_ty}
    Texp == expressionOk(s, exp, s_mtd),
    s_ty == scopeOf(s, Texp),
    types of Var{id@-} in s_ty |-> [(_, (_, T))].
  
  expressionOk(s, FieldAccess2Expression(SuperField(id)), s_mtd) = T :-
    query types filter LEX* EXT EXT* and { Var{id@-} }
                min $ < EXT, EXT < LEX, $ < LEX and true
                in s_mtd |-> [(_, (_, T))].
  
  expressionOk(s, FieldAccess2Expression(QSuperField(typeName, id)), s_mtd) = T :- {tyTN sTN}
    resolveTypeName(s_mtd, typeName) == (_, tyTN),
    scopeOf(s, tyTN) == sTN,
    types of Var{id@-} in sTN |-> [(_, (_, T))].
  
  //Methods
  expressionOk(s, Invoke(MethodName(id), args), s_mtd) = T :- {methods}
    types of Method{id@-} in s_mtd |-> methods,
    (_, FUNCTION(_, T)) == findMethod(s, expressionsOk(s, args, s_mtd), methods, s_mtd).
  
  expressionOk(s, InvokeQExp(exp, tyargs, id, args), s_mtd) = T :- {Texp sExp methods}
    expressionOk(s, exp, s_mtd) == Texp,
    scopeOf(s, Texp) == sExp,
    types of Method{id@-} in sExp |-> methods,
    (_, FUNCTION(_, T)) == findMethod(s, expressionsOk(s, args, s_mtd), methods, s_mtd).
  
  expressionOk(s, InvokeSuper(tyargs, id, args), s_mtd) = T :- {methods}
    query types filter LEX* EXT EXT* and { Method{id@-} }
                min $ < EXT, EXT < LEX, $ < LEX and true
                in s_mtd |-> methods,
    (_, FUNCTION(_, T)) == findMethod(s, expressionsOk(s, args, s_mtd), methods, s_mtd).
  
  expressionOk(s, InvokeQSuper(typeName, tyArgs, id, args), s_mtd) = T :- {tyTN sTN methods}
    resolveTypeName(s_mtd, typeName) == (_, tyTN),
    scopeOf(s, tyTN) == sTN,
    types of Method{id@-} in sTN |-> methods,
    (_, FUNCTION(_, T)) == findMethod(s, expressionsOk(s, args, s_mtd), methods, s_mtd).
  
  //Fixme does not do Subtyping
  /**
   * Tries to find a matching method. If not successful, returns the first match.
   */
  findMethod : scope * list(TYPE) * list((path * (occurrence * TYPE))) * scope -> (occurrence * TYPE)
  findMethod(s, argTys, [(_, p@(_, FUNCTION(argTys, _))) | _], s_mtd) = p.
  findMethod(s, argTys, [(_, p) | tail], s_mtd) = findMethodOrGuess(argTys, tail, p).
  
  findMethodOrGuess : list(TYPE) * list((path * (occurrence * TYPE))) * (occurrence * TYPE) -> (occurrence * TYPE)
  findMethodOrGuess(argTys, [], p) = p.
  findMethodOrGuess(argTys, [(_, p@(_, FUNCTION(argTys, _))) | _], _) = p.
  findMethodOrGuess(argTys, [_ | tail], p) = findMethodOrGuess(argTys, tail, p).
  
  
  
  //Literals
  expressionOk(s, Literal2Expression(Literal(ty)), s_mtd) = typeOk(s, ty).
  expressionOk(s, Literal2Expression(Null()), s_mtd) = CLASS(s).
  expressionOk(s, This(), s_mtd) = T :- {tThis}
    tThis == Id("this"), types of Var{tThis@-} in s_mtd |-> [(_, (_, T))].
  expressionOk(s, QThis(tyName), s_mtd) = T :-
    resolveTypeName(s_mtd, tyName) == (_, T).
  expressionOk(s, CL2Expression(_), s_mtd) = T :-
    resolveTypeName2(s_mtd, TypeName(PackageOrTypeName(PackageOrTypeName(Id("lang")), Id("java")), Id("Class"))) == (_, T).
  
  //InstanceCreation
  expressionOk(s, UI2Expression(NewInstance(typeArgs, annots, id, qids, typeArgs2, args)), s_mtd) = T :-
  {tyArgs}
    expressionsOk(s, args, s_mtd) == tyArgs,
    resolveTypeName(s_mtd, toTypeName([id | qidsToIds(qids)])) == (_, T).
  expressionOk(s, UI2Expression(NewInstance(typeArgs, annots, id, qids, typeArgs2, args, cbds)), s_mtd) = T :-
  {tyArgs}
    expressionsOk(s, args, s_mtd) == tyArgs,
    resolveTypeName(s_mtd, toTypeName([id | qidsToIds(qids)])) == (_, T).
  expressionOk(s, QualifiedInstance(exp, ui), s_mtd) = T :-
  {s_exp}
    scopeOf(s, expressionOk(s, exp, s_mtd)) == s_exp,
    expressionOk(s, UI2E(ui), s_exp) == T.
  
  expressionOk(s, ArrayAccess2Expression(ArrayAccess(e1, e2)), s_mtd) = T :-
    expressionOk(s, e1, s_mtd) == ARRAY(T),
    expressionOk(s, e2, s_mtd) == _.
  expressionOk(s, ACE2Expression(NewArray(ty, _, _)), s_mtd) = typeOk(s_mtd, ty).
  expressionOk(s, ACE2Expression(NewArrayInit(ty, _, _)), s_mtd) = typeOk(s_mtd, ty).
  
  expressionOk(s, Assign(e1, e2), s_mtd) = T :-
    expressionOk(s, e1, s_mtd) == T,
    expressionOk(s, e2, s_mtd) == _.
  
  expressionOk(s, Cond(e1, e2, e3), s_mtd) = T :-
    expressionOk(s, e1, s_mtd) == _,
    expressionOk(s, e3, s_mtd) == _,
    expressionOk(s, e2, s_mtd) == T.
  
  expressionOk(s, InstanceOf(e1, ty), s_mtd) = PRIMITIVE() :-
    expressionOk(s, e1, s_mtd) == _,
    typeOk(s_mtd, ty) == _.
  
  expressionOk(s, CastPrimitive(ty, exp), s_mtd) = typeOk(s_mtd, ty) :-
    expressionOk(s, exp, s_mtd) == _.
  expressionOk(s, CastReference(ty, _, exp), s_mtd) = typeOk(s_mtd, ty) :-
    expressionOk(s, exp, s_mtd) == _.
    
  //Eq, Add are flattened to primitives
  
  expressionOk(s, e, s_mtd) = PRIMITIVE().
  
  qidsToIds maps qidToId(list(*)) = list(*)
  qidToId : QualifiedId -> Id
  qidToId(QualifiedId(annots, id)) = id.
  toTypeName : list(Id) -> TypeName
  toTypeName([ id ]) = TypeName(id).
  toTypeName([ id | tail]) = TypeName(toPackageOrTypeName(tail), id).
  
  toPackageOrTypeName : list(Id) -> PackageOrTypeName
  toPackageOrTypeName([ id ]) = PackageOrTypeName(id).
  toPackageOrTypeName([ id | tail]) = PackageOrTypeName(toPackageOrTypeName(tail), id).
  
//-------------------------------------------------------------------------------------------------
//Types
//-------------------------------------------------------------------------------------------------
rules
  typesOk maps typeOk(*, list(*)) = list(*)
  typeOk: scope * Type -> TYPE
  typeOk(s, ReferenceType2Type(ClassType2ReferenceType(ct))) = classTypeOk(s, ct).
  typeOk(s, ReferenceType2Type(ArrayType2ReferenceType(at))) = arrayTypeOk(s, at).
  typeOk(s, PrimitiveType2Type(pt)) = PRIMITIVE().
  typeOk(s, ArrayType(ty, _)) = ARRAY(typeOk(s, ty)).
  
  arrayTypeOk: scope * ArrayType -> TYPE
  arrayTypeOk(s, ArrayTypePrimitive(_, _)) = ARRAY(PRIMITIVE()).
  arrayTypeOk(s, ArrayTypeClassType(ct, _)) = ARRAY(classTypeOk(s, ct)).
  
  scopeOf : scope * TYPE -> scope
  scopeOf(sg, CLASS(s)) = s.
  scopeOf(sg, ANNO(s)) = s.
  scopeOf(sg, INTF(s)) = s.
  scopeOf(sg, ENUM(s)) = s.
  scopeOf(sg, ARRAY(_)) = s :-
    scopes of Builtin{"array"@-} in sg |-> [(_, (_, s))].
  
  maybeScopeOf : scope * TYPE -> list(scope)
  maybeScopeOf(_, CLASS(s)) = [s].
  maybeScopeOf(_, ANNO(s)) = [s].
  maybeScopeOf(_, INTF(s)) = [s].
  maybeScopeOf(_, ENUM(s)) = [s].
  maybeScopeOf(sg, ARRAY(_)) = [s] :-
    scopes of Builtin{"array"@-} in sg |-> [(_, (_, s))].
  maybeScopeOf(_, _) = [].

//-------------------------------------------------------------------------------------------------
//Subtyping
//-------------------------------------------------------------------------------------------------
rules
  

//-------------------------------------------------------------------------------------------------
//Ambiguous handling
//-------------------------------------------------------------------------------------------------
rules
  /**
   * Resolves a type in the given scope and returns its results.
   */
  resolveTypeToPOT : scope * Id -> list((path * (occurrence * TYPE)))
  resolveTypeToPOT(s, id) = results :-
    types of Type{id@-} in s |-> results.
  resolveTypeToPOTIfEmpty : list((path * (occurrence * TYPE))) * scope * Id -> list((path * (occurrence * TYPE)))
  resolveTypeToPOTIfEmpty([], s, id) = resolveTypeToPOT(s, id).
  resolveTypeToPOTIfEmpty(l, _, _) = l.
  
  /**
   * Resolves a variable in the given scope. If that has no results, resolves as type instead.
   */
  //Tries as var, if that fails, tries as type.
  resolveVarsOrTypesToPOT maps resolveVarOrTypeToPOT(list(*), *) = list(*)
  resolveVarOrTypeToPOT : scope * Id -> list((path * (occurrence * TYPE)))
  resolveVarOrTypeToPOT(s, id) = results :-
  {varResults}
    types of Var{id@-} in s |-> varResults,
    //if results is empty, tries to resolve as type. Otherwise, returns the input
    resolveTypeToPOTIfEmpty(varResults, s, id) == results.
  resolveVarOrTypeToPOTIfEmpty : list((path * (occurrence * TYPE))) * scope * Id -> list((path * (occurrence * TYPE)))
  resolveVarOrTypeToPOTIfEmpty([], s, id) = resolveVarOrTypeToPOT(s, id).
  resolveVarOrTypeToPOTIfEmpty(l, _, _) = l.
  
  /**
   * Handles an ambiguous name, by either resolving it as a Var or as a Type (in that order).
   */
  handleAmbiguous : scope * AmbiguousName -> list((path * (occurrence * TYPE)))
  handleAmbiguous(s_mtd, AmbiguousName(id)) = results :-
  {varResults}
    types of Var{id@-} in s_mtd |-> varResults,
    //if varResults is empty, tries to resolve as type. Otherwise, returns the input
    resolveTypeToPOTIfEmpty(varResults, s_mtd, id) == results.
  handleAmbiguous(s_mtd, ambCur@AmbiguousName(amb, id)) = results :-
  {firstResults}
    //Resolve first part of name
    handleAmbiguous(s_mtd, amb) == firstResults,
    //If empty, we now try to resolve it as a FQT. Otherwise, we try to find our id in the scopes of our results.
    handleAmbiguousIfFirstEmpty(firstResults, s_mtd, ambCur, id) == results.
  
  /**
   * Helper function for ambiguous resolution.
   * If the given list is empty, it tries to resolve the given AmbiguousName as a fully qualified name.
   * Otherwise, it tries to find the given id in the scopes of the list.
   */
  handleAmbiguousIfFirstEmpty : list((path * (occurrence * TYPE))) * scope * AmbiguousName * Id -> list((path * (occurrence * TYPE)))
  handleAmbiguousIfFirstEmpty([], s, amb, id) = resolveAmbiguousAsType(s, amb).
  handleAmbiguousIfFirstEmpty(l, s, _, id) = flattenPOT(resolveVarsOrTypesToPOT(flattenScopes(potToScopes(s, l)), id)).
  
  /**
   * Resolves an ambiguous name as a fully qualified type.
   */
  resolveAmbiguousAsType : scope * AmbiguousName -> list((path * (occurrence * TYPE)))
  resolveAmbiguousAsType(s, AmbiguousName(id)) = results :-
    types of Type{id@-} in s |-> results.
  resolveAmbiguousAsType(s, AmbiguousName(amb, id)) = results :-
  {x i pkgs s_ref}
    amb2Pkg(amb, []) == Pkg{x@i},
    packages of Pkg{x@i} in s |-> pkgs,
    new s_ref,
    importPackages(s_ref, pkgs),
    resolveTypeToPOT(s_ref, id) == results.
  
  /**
   * Converts an ambiguous name to a package.
   */
  amb2Pkg : AmbiguousName * list(Id) -> occurrence
  amb2Pkg(AmbiguousName(id), ids) = Pkg{[id|ids]@-}.
  amb2Pkg(AmbiguousName(amb, id), ids) = amb2Pkg(amb, [id|ids]).

//-------------------------------------------------------------------------------------------------  
//Helper functions
//-------------------------------------------------------------------------------------------------
rules
  joinPOT : list((path * (occurrence * TYPE))) * list((path * (occurrence * TYPE))) -> list((path * (occurrence * TYPE)))
  joinPOT([], l) = l.
  joinPOT(l@[_ | _], []) = l.
  joinPOT([h | t], l) = [h | joinPOT(t, l)].
  
  potToScopes maps potToScope(*, list(*)) = list(*)
  potToScope : scope * (path * (occurrence * TYPE)) -> list(scope)
  potToScope(s, (_, (_, T))) = maybeScopeOf(s, T).
  
  flattenPOT : list(list((path * (occurrence * TYPE)))) -> list((path * (occurrence * TYPE)))
  flattenPOT([]) = [].
  flattenPOT([ l ]) = l.
  flattenPOT([ [h | t1] | t2]) = [h | joinPOT(t1, flattenPOT(t2))].
  
  flattenScopes : list(list(scope)) -> list(scope)
  flattenScopes([]) = [].
  flattenScopes([ l ]) = l.
  flattenScopes([ [h | t1] | t2]) = [h | joinScopes(t1, flattenScopes(t2))].
  
  joinScopes : list(scope) * list(scope) -> list(scope)
  joinScopes([], l) = l.
  joinScopes(l@[_ | _], []) = l.
  joinScopes([h | t], l) = [h | joinScopes(t, l)].
*/